diff -ru minisat2glucose/core/Solver.cc minisat_SWDiA5BY/core/Solver.cc
--- minisat2glucose/core/Solver.cc	2015-03-04 23:24:38.403085800 -0500
+++ minisat_SWDiA5BY/core/Solver.cc	2015-03-05 10:56:33.793615824 -0500
@@ -83,6 +83,7 @@
   , dec_vars(0), clauses_literals(0), learnts_literals(0), max_literals(0), tot_literals(0)
 
   , ok                 (true)
+  , local_learnts_dirty(false)
   , cla_inc            (1)
   , var_inc            (1)
   , watches_bin        (WatcherDeleted(ca))
@@ -97,9 +98,6 @@
   , global_lbd_sum     (0)
   , lbd_queue          (50)
   , trail_sz_queue     (5000)
-  , reduce_round       (1)
-  , reduce_base        (2000)
-  , next_reduce_at     (reduce_base)
   
   , counter            (0)
 
@@ -300,7 +298,7 @@
             Lit tmp = c[0];
             c[0] = c[1], c[1] = tmp; }
 
-        if (c.learnt())
+        if (c.learnt() && c.mark() == LOCAL)
             claBumpActivity(c);
 
         // Update LBD if improved.
@@ -308,7 +306,12 @@
             int lbd = computeLBD(c);
             if (lbd + 1 < c.lbd()){
                 if (c.lbd() <= 30) c.removable(false); // Protect once from reduction.
-                c.set_lbd(lbd); }
+                c.set_lbd(lbd);
+                if (lbd <= 5 && c.mark() == LOCAL){
+                    learnts_core.push(confl);
+                    local_learnts_dirty = true;
+                    c.mark(CORE); }
+            }
         }
 
         for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++){
@@ -625,38 +628,28 @@
 struct reduceDB_lt { 
     ClauseAllocator& ca;
     reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}
-    bool operator () (CRef x, CRef y) { 
-        if (ca[x].size() == 2) return 0;
-        if (ca[y].size() == 2) return 1;
-
-        if (ca[x].lbd() > ca[y].lbd()) return 1;
-        if (ca[x].lbd() < ca[y].lbd()) return 0;    
-    
-        return ca[x].activity() < ca[y].activity();
-    }    
+    bool operator () (CRef x, CRef y) const { return ca[x].activity() < ca[y].activity(); }
 };
 void Solver::reduceDB()
 {
     int     i, j;
 
-    sort(learnts, reduceDB_lt(ca));
+    sort(learnts_local, reduceDB_lt(ca));
 
-    if (ca[learnts[learnts.size() / 2]].lbd() <= 3) reduce_base += 1000;
-#ifdef REDUCE_BASE_BUG
-    if (ca[learnts.last()].lbd() > 5) reduce_base -= 1000;
-#endif
-
-    int limit = learnts.size() / 2;
-    for (i = j = 0; i < learnts.size(); i++){
-        Clause& c = ca[learnts[i]];
-        if (c.size() > 2 && c.lbd() > 2 && c.removable() && !locked(c) && i < limit)
-            removeClause(learnts[i]);
-        else{
-            if (!c.removable()) limit++;
-            c.removable(true);
-            learnts[j++] = learnts[i]; }
+    int limit = learnts_local.size() / 2;
+    for (i = j = 0; i < learnts_local.size(); i++){
+        Clause& c = ca[learnts_local[i]];
+        if (c.mark() == LOCAL)
+            if (c.removable() && !locked(c) && i < limit)
+                removeClause(learnts_local[i]);
+            else{
+                if (!c.removable()) limit++;
+                c.removable(true);
+                learnts_local[j++] = learnts_local[i]; }
     }
-    learnts.shrink(i - j);
+    learnts_local.shrink(i - j);
+    local_learnts_dirty = false;
+
     checkGarbage();
 }
 
@@ -693,6 +686,14 @@
 |    Simplify the clause database according to the current top-level assigment. Currently, the only
 |    thing done here is the removal of satisfied clauses, but more things can be put here.
 |________________________________________________________________________________________________@*/
+void Solver::cleanLearnts(vec<CRef>& learnts, unsigned valid_mark)
+{
+    int i, j;
+    for (i = j = 0; i < learnts.size(); i++)
+        if (ca[learnts[i]].mark() == valid_mark)
+            learnts[j++] = learnts[i];
+    learnts.shrink(i - j);
+}
 bool Solver::simplify()
 {
     assert(decisionLevel() == 0);
@@ -703,8 +704,12 @@
     if (nAssigns() == simpDB_assigns || (simpDB_props > 0))
         return true;
 
+    if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
+    local_learnts_dirty = false;
+
     // Remove satisfied clauses:
-    removeSatisfied(learnts);
+    removeSatisfied(learnts_core);
+    removeSatisfied(learnts_local);
     if (remove_satisfied)        // Can be turned off.
         removeSatisfied(clauses);
     checkGarbage();
@@ -767,9 +772,13 @@
             }else{
                 CRef cr = ca.alloc(learnt_clause, true);
                 ca[cr].set_lbd(lbd);
-                learnts.push(cr);
+                if (lbd <= 5){
+                    learnts_core.push(cr);
+                    ca[cr].mark(CORE);
+                }else{
+                    learnts_local.push(cr);
+                    claBumpActivity(ca[cr]); }
                 attachClause(cr);
-                claBumpActivity(ca[cr]);
                 uncheckedEnqueue(learnt_clause[0], cr);
             }
 
@@ -801,9 +810,8 @@
             if (decisionLevel() == 0 && !simplify())
                 return l_False;
 
-            if (conflicts >= next_reduce_at){
+            if (learnts_local.size() > 20000)
                 reduceDB();
-                next_reduce_at = (++reduce_round) * (reduce_base += 1300); }
 
             Lit next = lit_Undef;
             while (decisionLevel() < assumptions.size()){
@@ -1039,8 +1047,10 @@
 
     // All learnt:
     //
-    for (int i = 0; i < learnts.size(); i++)
-        ca.reloc(learnts[i], to);
+    for (int i = 0; i < learnts_core.size(); i++)
+        ca.reloc(learnts_core[i], to);
+    for (int i = 0; i < learnts_local.size(); i++)
+        ca.reloc(learnts_local[i], to);
 
     // All original:
     //
diff -ru minisat2glucose/core/Solver.h minisat_SWDiA5BY/core/Solver.h
--- minisat2glucose/core/Solver.h	2015-03-04 23:25:08.467305460 -0500
+++ minisat_SWDiA5BY/core/Solver.h	2015-03-05 10:56:28.755588437 -0500
@@ -29,16 +29,12 @@
 //#define WIDE_WALK
 //#define EXTRA_VAR_ACT_BUMP
 //#define INT_QUEUE_AVG
-//#define REDUCE_BASE_BUG
-//#define ZERO_LEVEL_LBD
 //#define LOOSE_PROP_STAT
 
 #ifdef GLUCOSE23
   #define WIDE_WALK
   #define EXTRA_VAR_ACT_BUMP
   #define INT_QUEUE_AVG
-  #define REDUCE_BASE_BUG
-  #define ZERO_LEVEL_LBD
   #define LOOSE_PROP_STAT
 #endif
 
@@ -49,6 +45,10 @@
 #include "core/SolverTypes.h"
 
 
+// Don't change the actual numbers.
+#define LOCAL 0
+#define CORE  3
+
 namespace Minisat {
 
 //=================================================================================================
@@ -216,7 +216,9 @@
     //
     bool                ok;               // If FALSE, the constraints are already unsatisfiable. No part of the solver state may be used!
     vec<CRef>           clauses;          // List of problem clauses.
-    vec<CRef>           learnts;          // List of learnt clauses.
+    vec<CRef>           learnts_core,     // List of learnt clauses.
+                        learnts_local;
+    bool                local_learnts_dirty;
     double              cla_inc;          // Amount to bump next clause with.
     vec<double>         activity;         // A heuristic measurement of the activity of a variable.
     double              var_inc;          // Amount to bump next variable with.
@@ -240,9 +242,6 @@
     float               global_lbd_sum;
     MyQueue<int>        lbd_queue;        // For computing moving averages of recent LBD values.
     MyQueue<int>        trail_sz_queue;   // Ditto, but for recent trail sizes (i.e., number of assigned variables).
-    int                 reduce_round;
-    uint64_t            reduce_base;      // Determines the next time of reduction.
-    uint64_t            next_reduce_at;
 
     ClauseAllocator     ca;
 
@@ -285,6 +284,7 @@
     void     removeSatisfied  (vec<CRef>& cs);                                         // Shrink 'cs' to contain only non-satisfied clauses.
     void     rebuildOrderHeap ();
     bool     binResMinimize   (vec<Lit>& out_learnt);                                  // Further learnt clause minimization by binary resolution.
+    void     cleanLearnts     (vec<CRef>& learnts, unsigned valid_mark);
 
     // Maintaining Variable/Clause activity:
     //
@@ -319,11 +319,7 @@
         counter++;
         for (int i = 0; i < c.size(); i++){
             int l = level(var(c[i]));
-#ifdef ZERO_LEVEL_LBD
-            if (seen2[l] != counter){
-#else
             if (l != 0 && seen2[l] != counter){
-#endif
                 seen2[l] = counter;
                 lbd++; } }
 
@@ -372,8 +368,8 @@
 inline void Solver::claBumpActivity (Clause& c) {
         if ( (c.activity() += cla_inc) > 1e20 ) {
             // Rescale:
-            for (int i = 0; i < learnts.size(); i++)
-                ca[learnts[i]].activity() *= 1e-20;
+            for (int i = 0; i < learnts_local.size(); i++)
+                ca[learnts_local[i]].activity() *= 1e-20;
             cla_inc *= 1e-20; } }
 
 inline void Solver::checkGarbage(void){ return checkGarbage(garbage_frac); }
@@ -402,7 +398,7 @@
 inline lbool    Solver::modelValue    (Lit p) const   { return model[var(p)] ^ sign(p); }
 inline int      Solver::nAssigns      ()      const   { return trail.size(); }
 inline int      Solver::nClauses      ()      const   { return clauses.size(); }
-inline int      Solver::nLearnts      ()      const   { return learnts.size(); }
+inline int      Solver::nLearnts      ()      const   { return learnts_core.size() + learnts_local.size(); }
 inline int      Solver::nVars         ()      const   { return vardata.size(); }
 inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }
 inline void     Solver::setPolarity   (Var v, bool b) { polarity[v] = b; }
