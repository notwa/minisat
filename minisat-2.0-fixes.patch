diff --git a/core/Solver.C b/core/Solver.C
index 404f4da..567a02c 100644
--- a/core/Solver.C
+++ b/core/Solver.C
@@ -114,7 +114,7 @@ bool Solver::addClause(vec<Lit>& ps)
         uncheckedEnqueue(ps[0]);
         return ok = (propagate() == NULL);
     }else{
-        Clause* c = Clause_new(ps, false);
+        Clause* c = Clause::Clause_new(ps, false);
         clauses.push(c);
         attachClause(*c);
     }
@@ -572,7 +572,7 @@ lbool Solver::search(int nof_conflicts, int nof_learnts)
             if (learnt_clause.size() == 1){
                 uncheckedEnqueue(learnt_clause[0]);
             }else{
-                Clause* c = Clause_new(learnt_clause, true);
+                Clause* c = Clause::Clause_new(learnt_clause, true);
                 learnts.push(c);
                 attachClause(*c);
                 claBumpActivity(*c);
diff --git a/core/SolverTypes.h b/core/SolverTypes.h
index 47e3023..919b60b 100644
--- a/core/SolverTypes.h
+++ b/core/SolverTypes.h
@@ -119,7 +119,7 @@ public:
 
     // -- use this function instead:
     template<class V>
-    friend Clause* Clause_new(const V& ps, bool learnt = false) {
+    static Clause* Clause_new(const V& ps, bool learnt = false) {
         assert(sizeof(Lit)      == sizeof(uint32_t));
         assert(sizeof(float)    == sizeof(uint32_t));
         void* mem = malloc(sizeof(Clause) + sizeof(uint32_t)*(ps.size()));
diff --git a/simp/SimpSolver.C b/simp/SimpSolver.C
index 22121c3..ac291f1 100644
--- a/simp/SimpSolver.C
+++ b/simp/SimpSolver.C
@@ -38,7 +38,7 @@ SimpSolver::SimpSolver() :
   , bwdsub_assigns     (0)
 {
     vec<Lit> dummy(1,lit_Undef);
-    bwdsub_tmpunit   = Clause_new(dummy);
+    bwdsub_tmpunit   = Clause::Clause_new(dummy);
     remove_satisfied = false;
 }
 
@@ -470,7 +470,7 @@ bool SimpSolver::eliminateVar(Var v, bool fail)
     elimtable[v].order = elimorder++;
     assert(elimtable[v].eliminated.size() == 0);
     for (int i = 0; i < cls.size(); i++){
-        elimtable[v].eliminated.push(Clause_new(*cls[i]));
+        elimtable[v].eliminated.push(Clause::Clause_new(*cls[i]));
         removeClause(*cls[i]); }
 
     // Produce clauses in cross product:
